//     Project: SBT NPM
//      Module:
// Description:
package de.surfice.sbtnpm

import java.io.{File => _, _}
import java.net.JarURLConnection

import de.surfice.sbtnpm.utils.{ExternalCommand, FileWithLastrun}
import org.scalajs.sbtplugin.ScalaJSPlugin
import sbt._
import Keys._
import Cache._
import com.typesafe.config.{Config, ConfigFactory}
import sbt.impl.DependencyBuilders
import utils._

object NpmPlugin extends AutoPlugin {
  type NpmDependency = (String,String)

  override lazy val requires = ScalaJSPlugin

  // Exported keys
  /**
   * @groupname tasks Tasks
   * @groupname settings Settings
   */
  object autoImport {
    /**
     * Defines the directory in which the npm `node_modules` resides.
     *
     * Defaults to `baseDirectory.value`.
     *
     * @group settings
     */
    val npmTargetDir: SettingKey[File] =
      settingKey[File]("Root directory of the npm project")

    val npmNodeModulesDir: SettingKey[File] =
      settingKey("Path to the node_modules dir")

    /**
      * List of the NPM packages (name and version) your application depends on.
      * You can use [semver](https://docs.npmjs.com/misc/semver) versions:
      *
      * {{{
      *   npmDependencies += "uuid" -> "~3.0.0"
      * }}}
      *
      * @group settings
      */
    val npmDependencies: SettingKey[Seq[NpmDependency]] =
      settingKey[Seq[NpmDependency]]("NPM dependencies (libraries that your program uses)")

    /** @group settings */
    val npmDevDependencies: SettingKey[Seq[NpmDependency]] =
      settingKey[Seq[NpmDependency]]("NPM dev dependencies (libraries that the build uses)")

    /**
     * Defines the path to the package.json file generated by the [[npmWritePackageJson]] task.
     *
     * Default: `npmTargetDirectory.value / "package.json"`
     *
     * @group settings
     */
    val npmPackageJsonFile: SettingKey[File] =
      settingKey[File]("Full path to the npm package.json file")

    val npmPackageJson: TaskKey[PackageJson] =
      taskKey[PackageJson]("Defines the contents of the npm package.json file")

    val npmWritePackageJson: TaskKey[FileWithLastrun] =
      taskKey[FileWithLastrun]("Create the npm package.json file.")

    /**
     *
     * @group tasks
     */
    val npmInstall: TaskKey[Long] =
      taskKey[Long]("Install npm dependencies")

    val npmRunScript: InputKey[Unit] =
      inputKey[Unit]("Run the specified npm script")

    val npmMain: SettingKey[Option[String]] =
      settingKey[Option[String]]("package.json 'main' property")

    val npmScripts: SettingKey[Seq[(String,String)]] =
      settingKey[Seq[(String,String)]]("npm scripts")

    val npmCmd: SettingKey[ExternalCommand] =
      settingKey[ExternalCommand]("npm command")

    val npmLibraryConfig: TaskKey[Config] =
      taskKey[Config]("Configuration loaded from package.conf files in libraries")

    val npmLibraryDependencies: TaskKey[Seq[NpmDependency]] =
      taskKey[Seq[NpmDependency]]("NPM dependencies defined by libraries")

    val npmLibraryDevDependencies: TaskKey[Seq[NpmDependency]] =
      taskKey[Seq[NpmDependency]]("NPM dev dependencies defined by libraries")

    val npmProjectConfig: SettingKey[File] =
      settingKey[File]("Project configuration file")
  }


  import autoImport._

  override lazy val projectSettings: Seq[Def.Setting[_]] = Seq(

    libraryDependencies += DepBuilder.toGroupID("de.surfice") %% "sbt-node-config" % Versions.sbtNode,

    npmProjectConfig := baseDirectory.value / "project.conf",

    npmCmd := ExternalCommand("npm"),

    npmTargetDir := baseDirectory.value,

    npmNodeModulesDir := npmTargetDir.value / "node_modules",

    npmPackageJsonFile := npmTargetDir.value / "package.json",

    npmDependencies := Nil,

    npmDevDependencies := Nil,

    npmMain := None,

    npmScripts := Nil,

    npmPackageJson := PackageJson(
      path = npmPackageJsonFile.value,
      name = name.value,
      version = version.value,
      description = description.value,
      dependencies = npmLibraryDependencies.value ++ npmDependencies.value,
      devDependencies = npmLibraryDevDependencies.value ++ npmDevDependencies.value,
      main = npmMain.value,
      scripts = npmScripts.value
    ),

    npmWritePackageJson := {
      val file = npmPackageJsonFile.value
      val lastrun = npmWritePackageJson.previous
      val projectConfig = npmProjectConfig.value
      val projectConfigIsNewer = projectConfig.canRead && projectConfig.lastModified() > lastrun.get.lastrun

      if(lastrun.isEmpty || lastrun.get.needsUpdateComparedToConfig(baseDirectory.value) || projectConfigIsNewer) {
        npmPackageJson.value.writeFile()(streams.value.log)
        FileWithLastrun(file)
      }
      else
        lastrun.get
    },

    npmInstall := {
      val file = npmWritePackageJson.value
      val lastrun = npmInstall.previous
      val dir = npmNodeModulesDir.value
      if(lastrun.isEmpty || file.lastrun>lastrun.get || !dir.exists()) {
        ExternalCommand.npm.install(npmTargetDir.value.getCanonicalFile,npmNodeModulesDir.value.getCanonicalFile,streams.value.log)
        new java.util.Date().getTime
      }
      else
        lastrun.get
    },

    npmRunScript := {
      import complete.DefaultParsers._

      npmInstall.value
      val script = spaceDelimited("<arg>").parsed.head
      ExternalCommand.npm.start("run-script",script)(streams.value.log,waitAndKillOnInput = true)
    },

    npmLibraryConfig := {
      val configString = loadPackageConfigs((dependencyClasspath in Compile).value, npmProjectConfig.value)
        .foldLeft("")( (s,in) => s + IO.readLines(new BufferedReader(new InputStreamReader(in))).mkString("\n") + "\n\n" )
      ConfigFactory.parseString(configString).resolve()
    },

    npmLibraryDependencies := npmLibraryConfig.value.getStringMap("npm.dependencies").toSeq,
    npmLibraryDevDependencies := npmLibraryConfig.value.getStringMap("npm.devDependencies").toSeq
  )

  private def loadPackageConfigs(dependencyClasspath: Classpath, projectConfig: File) =
    loadDepPackageConfigs(dependencyClasspath) ++ loadProjectConfig(projectConfig)

  private def loadProjectConfig(projectConfig: File): Option[InputStream] =
    if(projectConfig.canRead)
      Some(fin(projectConfig))
    else None

  private def loadDepPackageConfigs(cp: Classpath): Seq[InputStream] = {
    val (dirs,jars) = cp.files.partition(_.isDirectory)
    loadJarPackageConfigs(jars) // ++ loadDirPackageConfigs(dirs,log)
  }

  private def loadJarPackageConfigs(jars: Seq[File]): Seq[InputStream] = {
    val files = jars
      .map( f => new URL("jar:" + f.toURI + "!/package.conf").openConnection() )
      .map {
        case c: JarURLConnection => try{
          Some(c.getInputStream)
        } catch {
          case _: FileNotFoundException => None
        }
      }
      .collect{
        case Some(in) => in
      }
    files
  }


  private object DepBuilder extends DependencyBuilders
  private def fin(file: File): BufferedInputStream = new BufferedInputStream(new FileInputStream(file))
}

